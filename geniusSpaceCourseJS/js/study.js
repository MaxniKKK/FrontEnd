// Навчання
// ==============================================================
//                           Змінні
/*
let dynamicVar = 'Im let';
const staticVar = 'Im const';
var oldVar = 'Im var';

console.log(dynamicVar);
console.log(staticVar);
console.log(oldVar);
*/
// Відмінність const i let полягає в тому, що const забороняє
// повторне надання змінній будь-якого значення.
// Потрібно використовувати const за замовчуванням,
// проте коли точно знаємо що змінній треба буде надати інше значення
// в процесі виконання коду - використовувати let
// ==============================================================
//                      Як називати змінні?
// ==============================================================
//                      Строкові змінні (String)
// В найменуванні строкових змінних використовують ІМЕННИК
// ==============================================================
//                      Числові змінні (Number)
// Для найменувань діють наступні правила:
// • кількість - count
// • код чогось - code
// • розмір - size/length
// • номер - number
// Змінні з кількох слів пишуться разом
// ==============================================================
//                      Верблюжа нотація - camelCase
// camelCase - загальноприйнятий стандарт найменування змінних
// суть полягає в тому, що перше слово зі сполучення пишеться з малої букви
// а всі наступні - з великої
/*
const borderLeftWidth;
*/
// ==============================================================
//                      Булеве значення (Boolean)
// Назви булевих змінних мають бути питаннями з відповіддю так чи ні
// • містить - has/contain
// • це - is
// • може - can
// • повинен - should
// • можливість - able
// ==============================================================
// ==============================================================
//                      Властивість
//
// У даних є характеристики, наприклад у рядка є властивість довжини
// Синтаксис звернення до властивості дуже простий:
//  сутність.імя_властивості
/*
string.length
object.propertyName
*/
// ==============================================================
//                         Метод
// Метод - це виклик певної дії, активна операція.
// Наприклад можна додати або видалити елементи з колекції,
// перевести рядок в різний регістр тощо.
// Синтаксис виклику схожий на звернення до Властивості,
// проте в кінці треба додатки пару дужок ()
//  сутність.імя_методу()
/*
string.toLowerCase();
string.toUpperCase();
*/
// ==============================================================
// ==============================================================
//                         Типи даних
// ==============================================================
// У JavaScript є 8 основних типів даних:
//
// • Number(число)
// • String(рядок)
// • Boolean(булевий або логічний тип)
// • Symbol(символ)
// • BigInt(великі числа)
// • Null(порожнє значення)
// • Undefined(відсутність значення)
// • Object(об'єкт)
//
// Окремо по кожному:
// 1. Number
//  Цілі числа та числа з плаваючою комою. Після оголошення змінної можна
//  ініціалізувати її числовим значенням.
// 2. String
//  Рядки або просто текст. Рядок починається і закінчується:
//   • одиночною лапкою - '
//   • подвійними лапками - "
// 3. Boolean
//  Логічний тип даних, прапори стану. Має два значення: true i false
// 4. Symbol
//  Символ являє собою унікальний ідентифікатор. Створити символ можна
//  за допомогою Symbol(). Навіть якщо ми створимо багато символів
//  з однаковим описом, вони будуть мати різні значення.
// 5. BigInt
//  Числа > за (253-1) та < за (-253-1).
//  Тип Number має технічні обмеження і не може містити такі числа.
//  Використовуються для криптографії або мікросекундних часових міток.
// 6. Null
//  Особливе значення, яке означає НІЩО.
//  Використовується в ситуаціях, коли необхідно явно вказати відсутність значення
// 7. Undefined
//  Ще одне спеціальне значення. За умовчанням, коли змінна оголошується
//  але не ініціалізується(її значення не визначено), їй присвоюється
//  невизначений тип - undefined.
// 8. Object
//  Особливий тип. Усі інші називаються Примітивами, адже можуть містити
//  тільки 1 елемент.
//  В об'єктах зберігаються колекції даних і більш складні структури.
// ==============================================================
// ==============================================================
//                         Оператори
// ==============================================================
//                      Оператор typeof
//  Для отримання типу значення змінної використовується
//  оператор типу typeof, який повертає на місце свого
//  виклику тип значення змінної вказаного після нього.
//  Значення, що повертається - простий рядок(String), в якому вказаний тип.
/*
const b = null;
console.log(typeof b); // "object"
const c = 5;
console.log(typeof c); // "number"
const d = 'JavaScript is Awesome!';
console.log(typeof d); // "string"
const e = false;
console.log(typeof e); // "boolean"
*/
// ==============================================================
//                    Вивід даних/Ввід даних
// Взаємодія: alert, prompt, confirm.
// --------------------------------------------------------------
// • alert
//  Функція показує повідомлення та чекає доки користувач
//  не натисне кнопку "ОК"
/*
alert("Привіт"); 
*/
// --------------------------------------------------------------
// • prompt
//  Функція prompt показуэ модальне вікно з текстовим повідомленням,
//  полем, куди відвідувач може ввести текст, та кнопками ОК/Скасувати
/*
let age = prompt('Скільки вам років?');
*/
// --------------------------------------------------------------
// • confirm
//  Функція confirm показує модальне вікно з питанням question
//  та двома кнопками: OK та Скасувати
//  Результат буде true, якщо натиснути кнопку ОК,
//  інакше - false
/*
const question = 'Are you ge?';
let result = confirm(question);
*/
// ==============================================================
// ==============================================================
//       Вирішення логічних задач та побудова алгоритмів
// ==============================================================
//                   Математичні оператори
// Нічим не відрізняються від шкільного курсу математики.
// Оператори повертають значення в місце операції.
// Порядок обчислення математичних виразів це звична алгебра.
// Але важливо запам'ятати найменування складових:
// +-*/% називають операторами,
// а те, на чому їх застосовують - операндами.
/*
const x = 10;
const y = 5;
console.log(x + y); // 15
console.log(x - y); // 5
console.log(x * y); // 50
console.log(x / y); // 2
console.log(x % y); // 0
*/
// ==============================================================
//                   Оператори порівняння
// Використовуються для порівняння значень.
// Результатом свого виконання повертать bool'и - true або false
/*
const a = 10;
const b = 5;
console.log(a > b);   // true
console.log(a < b);   // false
console.log(a >= b);  // true
console.log(a <= b);  // false
console.log(a == b);  // false
console.log(a != b);  // true
console.log(a === b); // false
console.log(a !== b); // true
*/
// ==============================================================
//                       == або ===
// Завжди використовуйте строгу рівність === і строгу нерівність !==
// Оператори == і != виконують перетворення типів порівнюваних значень,
// що може призвести до помилок.
// ==============================================================
//                    Логічні оператори
// В JavaScript існує 4 логічні оператори:
// • ||(АБО)
// • &&(І)
// • !(НЕ)
// • ??(оператор null-об'єднання)
// --------------------------------------------------------------
// ||(АБО)
//  Оператор АБО представлений двома символами вертикальної лінії
//  Логічний оператор АБО призначений для маніпулювання лише булевими значеннями
//  Якщо будь-який з його аргументів означає true - повертається true,
//  інакше повертається false
/*
const a = true;
const b = false;
let result = a || b;
console.log(result); // "true"
*/
// --------------------------------------------------------------
// &&(І)
//  Оператор І представлений двома амперсандами &&
//  Повертає true, якщо обидва оператори є правдивими,
//  і false в іншому випадку.
/*
const a = true;
const b = false;
let result = a && b;
console.log(result); // "false"
*/
// --------------------------------------------------------------
// !(НЕ)
//  Булевий Оператор НЕ представлений знаком оклику !
//  Оператор приймає один аргумент і виконує наступне:
//  Перетворює операнд на булевий тип : true/false
//  Повертає зворотнє значення.
/*
const value = true;
let result = !value;
console.log(result); // "false"
console.log(!result); // "true"
*/
//  Подвійний НЕ !! іноді використовується для перетворення
//  значення в булевий тип
//  Тобто, перший !(НЕ) перетворює значення на булеве і повертає зворотнє,
//  а другий !(НЕ) інвертує його знову
/*
console.log(!!'не пустий рядок'); // true
console.log(!!null); // false
*/
// ==============================================================
// ==============================================================
//               Умовні розгалуження if-else
// ==============================================================
//                     Інструкція if
// Інструкція if(...) обчислює умову в дужках і,
// якщо результат умови true, виконує блок коду.
/*
if (5 * 5 === 25) {
	console.log('Виведе в консоль цей рядок');
}
*/
// --------------------------------------------------------------
//                      Блок else
// Вираз if може містити необов'язковий блок else(інакше).
// Він виконується коли умова є хибною
/*
if (5 * 5 === 24) {
	console.log('1');
} else {
	console.log('2');
}
*/
// --------------------------------------------------------------
//                   Декілька умов - else if
// Іноді ми хотіли б перевірити кілька варіантів умови.
// Блок else if дозволяє нам це зробити.
/*
if (5 + 5 === 20) {
	console.log('5+5===20');
} else if (2 + 2 === 4) {
	console.log('2+2===4');
} else console.log('no');
*/
// ==============================================================
//              Умовний оператор ? (тернарний оператор)
// Умовний оператор ?(тернарний оператор) дає нам зробити порівняння
// ще в більш короткій і простій формі.
// Оператор представлений знаком питання ?
// Його називають тернарним, оскільки оператор має три операнди
// Синтаксис:
// let result = умова ? значення1(якщо умова true) : значення2(якщо умова false)
/*
2 + 2 === 4 ? console.log('true') : console.log('false');
5 * 5 === 24 ? console.log('true') : console.log('false');
*/
// ==============================================================
//                    Конструкція switch
// Конструкція switch може замінит кілька if
// Вона дає можлиаість більш наочного способу порівняння
// значення відразу з кількома варіантами
// Конструкція switch має один або більше case блоків
// та необов'язковий блок default
/*
let x = 'value3';

switch (x) {
	case 'value1': //if(x==="value1")
		console.log('Its value1');
		break;
	case 'value2': //if(x==="value2")
		console.log('Its value2');
		break;
	default:
		console.log('its nichego');
}
*/
// Значення змінної х перевіряється на строгу рівність (===) значень
// із першого блоку case("value1"),
// потім значенню із другого блоку case("value2") і так далі
// Якщо строго рівне значення знайдено, то switch починає виконання
// коду із відповідного case до найближчого break
// або до кінця конструкції switch(якщо break немає)
// ==============================================================
// ==============================================================
//                          Масиви
// Масив - структура даних для зберігання та маніпулювання
// колекцією індексованих значень. Використовуються для
// зберігання впорядкованих колекцій даних, наприклад,
// списку курортів, товарів, клієнтів у готелі тощо.
// Синтаксис для створення нового масиву - квадратні дужки []
// зі списком елементів розділених комами.
// У масиві може зберігатися будь-яка кількість елементів
// будь-якого типу.
//
// Оголошення
// Існує два типи синтаксису для створення порожнього масиву:
// • let arr = new Array();
// • let arr = [];
// Майже завжди використовують другий тип синтаксису.
// Елементи масиву нумеруються починаючи з нуля.
// Можна отримати елемент масиву вказавши його номер у квадратних дужках []
// Ми можемо вказати початкові елементи масиву у квадратних дужках:
/*
let fruits = ['Apple', 'Orange', 'Plum'];
console.log(fruits[0]); // "Apple"
*/
// ==============================================================
//                      Перевизначення
// Елементи масиву можна замінювати та додавати,
// звертаючись до елемента масиву за індексом
// fruits[2] = 'Pear'
// Та додовати новий:
// fruits[3] = 'Lemon'
//
// Загальна кількість елементів масиву зберігається
// у його властивості length:
/*
let fruits = ['Apple', 'Orange', 'Plum'];
console.log(fruits.length);  // 3
*/
//
// У масивах можуть зберігатись елементи будь-якого типу:
/*
let arr = ['Apple', { name: 'John' }, true, function () {}];
console.log(arr);
*/
// ==============================================================
//                        Методи масиву
// 1. Методи push(), pop(), shift(), unshift()
// --------------------------------------------------------------
// • push() - дозволяє додати один або кілька елементів до кінця масиву.
//   Метод повертає значення властивості length, що визначає кількість елементів у масиві
/*
arr.push('Lemon');
console.log(arr); // (5) ['Apple', {…}, true, ƒ, 'Lemon']
console.log(arr.push()); // 5
*/
// --------------------------------------------------------------
// • pop() - видаляє елемент із кінця масиву
//   Метод повертає значення видаленого елементу
/*
console.log(arr.pop()); // f () {}
console.log(arr.pop()); // true
*/
// --------------------------------------------------------------
// • shift() - видаляє елемент із початку масиву.
//   Метод повертає значення видаленого елементу
/*
console.log(arr.shift()); // "Apple"
console.log(arr.shift()); // {name: 'John'}
*/
// --------------------------------------------------------------
// • unshift() - додає елемент на початок масиву
// Метод повертає значення властивості length, що визначає кількість елементів у масиві
/*
console.log(arr.unshift('Lemon')); // 5
console.log(arr); //(5) ['Lemon', 'Apple', {…}, true, ƒ]
*/
// ==============================================================
// 2. Метод splice()
// splice() - це універсальний "швейцарський ніж" для роботи з масивами
// Вміє все: додавати, видаляти і замінювати елементи
// Синтаксис:
// arr.splice(position, num)
//   • position - вказує позицію(індекс) першого елемента видалення
//   • num - визначає кількість елементів, що видаляються
// Метод splice() змінює вихідний масив та повертає масив, що містить видалені елементи
/*
arr.splice(1, 2);
console.log(arr); // (2) ['Apple', ƒ]
*/
// ==============================================================
// 3. Метод slice()
// Синтаксис методу slice() однаковий для рядків та масивів.
// Його просто запам'ятати:
// Він дозволяє витягувати елементи підмножини масиву і додавати в новий масив.
// Найчастіше використовується для створення копії частини або цілого вихідного масиву
// arr.slice(begin, end) - копіює елементи від begin до, але не включаючи, end.
//   • begin - визначає індекс з якого слід розпочати вилученння
//   • end - визначає індекс, на якому слід закінчити вилучення.
//     Метод slice() не включає елемент з індексом end у вилучення.
// Обидва параметри begin та end не обов`язкові, якщо вони не вказані
// тоді копіюватись буде увесь масив.
// Якщо не вказати лише параметр end - метод використає довжину масиву(length)
// для параметра end
// Метод slice() не змінює вихідний масив, а повертає новий масив,
// що містить копію елементів вихідного.
/*
arr.slice(1, 3);
console.log(arr); // Не зміниться

let newArr = arr.slice(1, 3);
console.log(newArr); // Поверне новий масив - (2) [{…}, true]
*/
// ==============================================================
// 4. Метод concat()
// Метод concat() створює новий масив, в який копіює дані з інших масивів та додаткові значення
// arr.concat(arg1, arg2...)
// Метод приймає будь-яку кількість аргументів - масивів чи значень.
// Результатом є новий масив, що містить елементи з arr,
// потім arg1, arg2 тощо.
// Якщо аргумент argN є масивом, то всі його елементи копіюються.
// В іншому випадку буде скопійовано сам аргумент.
/*
const oldClients = ['Mango', 'Ajax', 'Poly', 'Kiwi'];
const newClients = ['Monkong', 'Singu'];
const allClients = oldClients.concat(newClients);
console.log(allClients); // (6) ['Mango', 'Ajax', 'Poly', 'Kiwi', 'Monkong', 'Singu']
*/
// ==============================================================
// 5. Методи indexOf(), lastIndexOf(), includes()
// Методи indexOf(), lastIndexOf(), includes() мають однаковий
// синтаксис і роблять по суті те ж саме, що і їх рядкові аналоги,
// але працюють з елементами замість символів.
// --------------------------------------------------------------
// • indexOf(item, from) - шукає item починаючи з індексу from,
//   і повертає індекс, на якому був знайдений шуканий елемент,
//   в іншому випадку повертає значення -1
/*
let arr = ['Apple', { name: 'John' }, true, function () {}];
console.log(arr.indexOf(true, 0)); // 2 (0,1,2)
*/
// --------------------------------------------------------------
// • lastIndexOf(item, from) - те ж саме, але шукає з кінця.
/*
let arr = ['Apple', { name: 'John' }, true, function () {}];
console.log(arr.lastIndexOf(true, -1)); // 2 (-1,3,2)
*/
// --------------------------------------------------------------
// • includes(item, from) - шукає item, починаючи з індексу from,
//   і повертає true, якщо пошук успішний
/*
let arr = ['Apple', { name: 'John' }, true, function () {}];
console.log(arr.includes(true, 0)); // true
*/
// ==============================================================
// ==============================================================
//                        Цикли
// ==============================================================
// Цикл - конструкція, що управляє, у високорівневих мовах програмування
// призначена для організації багаторазового виконання набору інструкцій
//
// Тіло циклу - послідовність інструкцій, призначена для багаторазового виконання
//
// Ітерація - одиничне виконання тіла циклу
//
// Умова виходу - вираз, що визначає чи буде в черговий раз
// виконуватися ітерація чи цикл завершиться
//
// Лічильник - змінна, що зберігає поточний номер ітерації.
// Цикл необов'язково містить лічильник, і не повинен бути один,
// умова виходу з циклу може залежати від кількох змінних у циклі.
//
// Виконання будь-якого циклу включає
//  • початкову ініціалізацію змінних циклу
//  • перевірку умови виходу
//  • виконання тіла циклу
//  • оновлення змінних циклу на кожній ітерації
// ==============================================================
//                    Цикл "while"
// Цикл while має наступний синтаксис:
//  while (умова){
//    // код
//    // "тіло циклу"
//  }
// Доки умова є вірною, виконуєтсья код із тіла циклу
// Наприклад, цикл нижче виводить i поки i < 3
/*
    let i = 0;
    while (i < 3) {
      console.log(i);
      i++;
    }
*/
// --------------------------------------------------------------
//                   Цикл "do...while"
// Перевірка умови може бути переміщена нижче тіла циклу використовуючи
// do...while синтаксис:
//  do {
//    // тіло циклу
//  } while(умова)
// Цикл спочатку виконує тіло, а потім перевіряє умову,
// і поки умова є true, цикл виконується знову і знову
// Наприклад:
/*
    let i = 0;
    do {
      console.log(i);
      i++;
    } while (i < 3);
 */
// --------------------------------------------------------------
//                      Цикл for
// Цикл із лічильником - цикл, у якому деяка змінна змінює
// своє значення від заданого початкового до кінцевого значення,
// з деяким кроком, і кожного значення цієї змінної тіло
// циклу виконується один раз.
//
// У більшості процедурних мов програмування реалізується
// оператором for, у якому вказується лічильник, необхідну кількість
// ітерацій так крок, з яким змінюється лічильник
//
// Алгоритм виконання циклу for:
// • Ініціалізація(initialization) - вираз ініціалізації виконується
//   один раз, коли починається цикл. Використовується для ініціалізації
//   змінної - лічильника. Якщо використовується ключове слово let,
//   зміна лічильника є локальною для циклу.
// • Умова(condition,test) - вираз, що оцінюється перед кожною ітерацією
//   циклу. Тіло циклу виконується лише тоді, коли вираз умови набуває значення
//   true. Цикл завершується, якщо значення буде false.
// • Тіло(statements) - виконується у разі задоволення умови
// • Пост-вираз(post-expression) - виконується після тіла кожної ітерації
//   циклу, але перед перевіркою умови.
//   Використовується для оновлення лічильника.
/*
    const max = 10;

    for (let i = 0; i < max; i++) {
      console.log(i);
    }
*/
// ==============================================================
//                  Переривання циклу: break
// Зазвичай цикл завершується, коли умова стає false.
// Але ми можемо в будь-який момент вийти з циклу,
// використавши спеціальну директиву break
/*
    for (let i = 0; i < 10; i++) {
      if (i === 5) {
        console.log('5 ітерація!');
        break;
      }
    }
*/
// --------------------------------------------------------------
//          Продовження з наступної ітерації: continue
// Директива continue - це "полегшена версія" break
// Вона не зупиняє весь цикл.
// Натомість вона зупиняє поточну ітерацію і починає виконання циклу
// спочатку з наступної ітерації(якщо умова циклу досі вірна)
//
// Її зручно використовувати коли закінчили з поточною операцією
// і хочемо продовжити з наступної
//
// Цикл нижче використовує continue щоб вивести лише непарні значення
/*
    for (let i = 0; i < 10; i++) {
      // якщо умова справджується - починаємо з наступної ітерації
      if (i % 2 === 0) continue;
      console.log(i); // 1, 3, 5, 7, 9
    }
*/
// ==============================================================
//                   Області видимості
// Область видимості змінних(variable scope) - доступність змінних
// у певному місці коду. Є кілька областей видимості:
// • Глобальна
// • Блокова
// • Eval
// • Функції
//
// Глобальна область видимості використовується за замовчуванням.
// Усі і всі мають доступ до змінних оголошених у ній.
// Змінні оголошені у глобальній області видимості вразливі,
// оскільки може змінити будь-яку ділянку коду.
//
// Будь-яка конструкція, що використовує фігурні дужки {}
// (умови, цикли, функції тощо) створює нову локальну область видимості,
// і змінні, оголошені в цій області видимості, використовуючи
// let або const, не доступні поза цим блоком.
// ==============================================================
// ==============================================================
//                         Функції
// Функції - це основні "будівельні блоки" програми.
// Вони дозволяють робити однакові дії багато разів без повторення коду
//
// Функції можна уявити як чорну скриньку, вони отримують
// щось на вході(дані) і віддають щось на виході(результат виконання всередині функції)
//
// Функції є інструментом структурування великих програм,
// зменшення повторень та ізолювання коду.
// --------------------------------------------------------------
//                        Параметри
// Ми можемо передати в функцію довільні дані використовуючи Параметри
// В наступному прикладі функція має 2 параметри: from i text
/*
    function showMessage(from, text) {
      console.log(`${from} + ${text}`);
    }

    showMessage('Anna', 'Hey!'); // Anna + Hey!
*/
// Якщо викликати функцію без аргументів, тоді відпоідні значення стануть undefined
// --------------------------------------------------------------
//                      Function Declaration
// Function Declaration(оголошення функції) - починається з ключового слова
// function, за яким може йти необов`язкове ім`я функції.
//
// У круглих дужках йдуть параметри - перерахування даних, які функція
// буде отримувати ззовні. Параметрів може бути кілька
// або взагалі не бути. Тоді записуються порожні круглі дужки.
//
// Далі йде тіло функції укладене у фігурні дужки {},
// що містить інструкції, які необхідно виконати при виклику функції.
// Тіло функції завжди укладають в фігурні дужки, навіть якщо воно складається з
// однієї інструкції.
//
// Ім'я функції - дієслово, що починається з маленької літери,
// що відповідає на питання "Що зробити?"
//
// Наприклад: findSmallestNumber, fetchUserInfo, validateInput
//
// Оператор return визначає значення, що повертається.
// Коли інтерпретатор доходить до return, він відразу ж виходить з функції,
// і повертає це значення в місце коду, де функція була викликана.
//
// Оператор return без виразу повертає значення undefined
// При відсутності обороту в тілі функції вона все одно поверне
// значення undefined.
//
// Потім, коли необхідно, функція викликається за допомогою імені та
// круглих дужок (), усередині яких можуть бути передані аругменти.
//
// Аргументи - цей термін використовується під час виклику функції,
// коли ми передаємо якісь значення в функцію
//
// Параметри - цей термін використовується при оголошенні функції,
// це ті локальні змінні всередині функції, в які будуть записані
// значення аргументів під час її виклику.
//
// В JavaScript важливий порядок оголшення параметрів функції
// Немає ніякого іншого механізму пояснити інтерпретатору як значення
// аргументів функції під час виклику пов'язані з параметрами.
//
// Порядок оголошення параметрів відповідає порядку передачі аргументів
// під час виклику функції: значення першого аргументу буде присвоєно першому параметру,
// другого аргументу - другому параметру і так далі.
// Якщо параметрів буде менше ніж аргументів, то параметрам без значень буде присвоєно undefined
// --------------------------------------------------------------
//                     Functional expression
// Functional expression(функціональний вираз) - звичайне оголошення
// змінної, значення якої буде функцією.
//
// Оголосимо змінну add і надамо їй функцію, що приймає 3 значення
// і повертає результат складання цих значень
/*
    const add = function (a, b, c) {
      return a + b + c;
    };
*/
// --------------------------------------------------------------
//                       Arrow functions
// Arrow functions(стрілкові функції) - ще один простіший та коротший синтаксис
// для створення функції, який часто доцільніше використовувати замість Функціонального виразу
// Виглядають вони так:
/*
    let func = (arg1, arg2, ..., argN) => expression;
*/
// Цей код створить функцію func з аргументами arg1...argN, що обчислює expression
// з правого боку (використовуючи ці аргументи) та повертає його результат.
// Іншими словами, це те ж саме, що і:
/*
    let func = function(arg1,arg2,...,argN){
      return expression;
    }
*/
// --------------------------------------------------------------
//          Callback functions(функції зворотнього виклику)
// Розглянемо інші приклади передачі функції як значення та використання
// Функціональних виразів(Functional expression)
// Для цього напишемо функцію ask(question, yes, no) з трьома параметрами:
//  • question - текст запитання
//  • yes - функція, що буде викликатись, якщо відповідь буде "Так"
//  • no - функція, що буде викликатись, якщо відповідь буде "Ні"
//
// Функція ask() повинна поставити запитання question і,
// залежно від відповіді користувача, викликати yes() або no()
/*
    function ask(question, yes, no) {
      if (confirm(question)) yes();
      else no();
    }
    function showOk() {
      alert('Ви погодились');
    }
    function showCancel() {
      alert('Ви скасували виконання');
    }
    // функції showOk i showCancel передаються як аргументи до ask()
    ask('you are gay!', showOk, showCancel);
*/
// ==============================================================
// ==============================================================
//             Лексичне оточення (Lexical environment)
// Lexical Environment - це тип специфыкацыъ, який використовується
// для дозволу імен ідентифікаторів при пошуку конкретних
// змінних та функцій на основі лексичної структури вкладеності
// коду ECMAScript. Лексичне оточення складається із запису
// середовища і, можливо, нульового посилання на зовнішнє
// Лексичне середовище.
//
// Технічно Лексичне оточення - це об'єкт з двома властивостями:
// • запис оточення(тут зберігаються всі оголошення)
// • посилання на ЛО породжуючого контексту
//
// Через посилання на контекст-батька поточного контексту ми можемо
// у разі потреби отримати посилання на контекст-дідусь контексту-батька
// і т.д до глобального контексту, посилання на батько якого буде null
//
// З цього випливає, що Лексичено оточення - це зв'язок сутностей
// з контекстами, що їх породили.
/*
let x = 10;
let y = 20;
const foo = (z) => {
	let x = 100;
	return x + y + z;
};
console.log(foo(30)); // Поверне 150. Лексичне оточення для foo буде виглядати так:
                      // {record: {z:30, x:100}, parent: _parent};
                      // _parent буде вказувати на глобальне ЛО
                      // {record: {x:10, y:20}, parent: null }
*/
// Технічно процес дозволоу імен ідентифікаторів відбуватиметься так:
// Послідовне опитування об'єктів у ланцюзі ЛО доти, доки не буде
// знайдено потрібний ідентифікатор. Якщо не знайдено - ReferenceError
//
// ЛО створюється та наповнюється на етапі створення контексту. Коли
// поточний контекст закінчує своє виконання, він видаляється зі стека викликів.
//
// ЛО може жити до тих пір поки на нього є хоч одне посилання.
// --------------------------------------------------------------
//                  Контексти і виклики
// При виклику функції всередині її тіла можуть викликатися
// інші функції, а в них інші і т.д.
//
// JavaScript - однопоточна мова, тобто в одну одиницю часу може
// виконуватися тільки одна операція.
//
// Це означає, що вже викликані функції, які закінчили своє виконання,
// повинні чекати виконання функцій викликаних у собі,
// щоб продовжити своє виконання.
// Відповідно необхідний механізм зберігання списку функцій,
// які були викликані, але ще не закінчили своє виконання,
// і саме за це відповідає СТЕК контекстів виконання.
//
// Стек - структура даних, яка працює за принципом
// останнім прийшов - першим пішов(LIFO - last in first out)
// Останнє, що ви додали у стек, буде видалено з нього першим,
// тобто можна додати або видалити елементи лише з верхівки стека.
//
// Контекст виконання(execution context) - внутрішня конструкція мови
// для відстеження виконання функції, що містить метаінформацію про її виклик
//
// Глобальний контекст виконання(global execution context) -
// контекст за замовчуванням, сам файл скрипта.
// Це функція, яка запускається на виконання.
//
// Контекст виконання функції(functional execution context) -
// створюється щоразу під час виклику.
//
// Стек викликів(Execution context stack, call stack) -
// внутрішня конструкція двигуна, що містить усі контексти виконання.
//
// Stack frame(кадр стека, запис стека) - структура, яка додається
// на стек при виклику функції. Зберігає деяку метаінформацію:
// ім'я функції, аргументи які були передані під час виклику та номер
// рядка в якому відбувся виклик.
// --------------------------------------------------------------
//                     Замикання(closure)
// Замикання - це зв'язок між функцією та її ланцюжком областей видимості.
//
// Цей механізм можливий завдяки лексичному оточенню. При виклику функції,
// її лексичне оточення отримує посилання на ту область видимості, де
// функцію було оголошено(зовнішнє лексичне оточення) цим отримуючи доступ
// до змінних із неї, буквально утримуюючи у пам'яті таблицю доступних змінних.
//
// Разом, замикання це термін який описує здатність функції
// запам'ятовувати лексичне оточення в якому вона була оголошена, і
// продовжувати отримувати доступ до змінних з цього лексичного оточення
// незалежно від того, де вона була викликана.
//
// Тобто: функції автоматично запам'ятовують, де вони були створені,
// використовуючи приховану властивість [[Environment]],
// а потім їх код може отримати доступ до зовнішніх змінних.
//
// Коли під час співбесід розробник отримує запитання
// "що таке замикання?", правильною відповіддю буде визначення замикання та пояснення,
// що всі функції в JavaScript є замиканнями, і, можливо, ще кілька слів про
// технічні деталі: властивість [[Environment]], і як взагалі працюють лексичні середовища.
// ==============================================================
// ==============================================================
//                          This
// Ключове слово this є однією з найзаплутаніших частин JavaScript на старті вивчення.
// Необхідно засвоїти лише одне правило для визначення this:
// Значення контексту всередині функції визначається не в момент її створення, а момент виклику.
// Тобто значення цього визначається тим, як викликається функція, а не де вона була оголошена.
//
// У глобальній області видимості, якщо скрипт виконується не в строгому режимі,
// this посилається на window.
// У строгому режимі this, в глобальній області видимості буде undefined.
//
// Якщо функція була викликана як метод об'єкта,
// контекст буде посилатися на об'єкт, частиною якого є метод.
// --------------------------------------------------------------
//                  Методи об'єкту i this
// Об'єкти зазвичай ствроюються для представлення сутностей
// реального світу, таких як користувач, замовлення тощо:
/*
let user = {
	name: 'Ivan',
	age: 30,
};
*/
// І в реальному світі користувач може діяти і вибрати щось із кошика
// для покупок, авторизуватися, виходити із системи тощо.
//
// Дії представлені в JavaScript функціями у властивостях об'єкта:
/*
user.sayHi = function () {
	console.log('Привіт');
};
user.sayHi();
*/
// Як правило, метод об'єкта повинен отримувати доступ до інформації,
// що зберігається в об'єкті, для виконання своєї роботи
// Наприклад, коду всередині user.sayHi() може знадобитися
// ім'я, що зберігається в об'єкті user
//
// Для доступу до інформації всередині об'єкта використовується
// слово this
// --------------------------------------------------------------
//           this у функціях зворотнього виклику
// Коли ми передаємо метод, який використовує this, як параметр,
// який буде використовуватися як функція зворотнього виклику, буде проблема.
// Вирішення цієї проблеми розглядається в наступній секції:
/*
const hotel = {
	name: 'Resort Hotel',
	showThis() {
		console.log(this);
	},
};
*/
// Під час виклику fn, callback буде посиланням на функцію showThis об'єкта hotel
// Її виклик відбувається у глобальному контексті, про hotel вона нічого не знає
// Відповідно this не посилатиметься на hotel.
/*
const fn = function (callback) {
	callback();
};
// Передається посилання на функцію, а її виклик
fn(hotel.showThis);
*/
// --------------------------------------------------------------
//                Arrow functions and this
// Стрілочні функції не мають свого this.
// На відміну від звичайних функцій, змінити значення цієї
// всередині стрілки після її оголошення не можна
// ==============================================================
// ==============================================================
//          Методи функцій call,apply,bind
// Присвоєння функції як методу об'єкта може здатися гарною ідеєю.
// Але чи варто зберігати такі методи?
// Дублювання вже існуючих функцій як методів об'єкта займатиме
// ресурси, не приносячи жодних помітних вигод.
// --------------------------------------------------------------
// Call
// Запам'ятати правило використання call досить легко:
// метод call викличе функцію fn передавши їй посилання
// на об'єкт obj, а також аргументи arg1, arg2 і т.д.
/*
const userInfo = {
	name: 'name',
	age: 98,
	fn: function (job, city) {
		console.log(`Name is ${this.name}`);
		console.log(`Age is ${this.age}`);
		console.log(`Job is ${job}`);
		console.log(`City is ${city}`);
	},
};
const Vano = {
	name: 'Ivan',
	age: 45,
};

userInfo.fn.call(Vano, 'developer');
/
// --------------------------------------------------------------
// Apply
// Метод apply - повний аналог методу call, крім того,
// що синтаксис виклику аргументів вимагає не перерахування,
// а масив
/*
userInfo.fn.apply(Vano, ['developer', 'Lviv']);
*/
// --------------------------------------------------------------
// Bind
// Ми розглянули випадки, коли миттєво необхідно викликати
// функцію з іншим контекстом, для цього використовуються
// методи call i apply.
// Але у випадку функції зворотнього дзвінка, коли необхідно
// не викликати функцію на місці, а передати посилання на цю
// функцію, причому з прив'язаним контекстом, call i apply не підходять
// Метод bind дозволяє вирішити це завдання
//
// Метод bind створює копію функції fn з прив'язаним контекстом
// obj та аргументами arg1, arg2 тощо, після чого повертає її як результат
// роботи. В результаті ми отримуємо копію функції з прив'язаним
// контекстом, яку можна передати куди завгодно і викликати будь-коли
//
// Найчастіше метод bind використовується для прив'язки контексту
// передачі методів об'єкта як функцій зворотнього виклику.
//
// Візьмемо приклад із попередньої секції.
// Завдання прив'язки контексту вирішується використанням
// методу bind, передаючи копію методу з прив'язаним контекстом.
// ==============================================================
// ==============================================================
//                   Об'єкти та класи
// Процедурне програмування - набір не пов'язаних функцій і змінних
// для зберігання та обробки інформації. Цей підхід простий і прямолінійний
// але при зростанні кодової бази результатом може бути те, що
// називається spaghetti code - тісно пов'язаний код
//
// ООП(Об'єктно-орієнтоване програмування) - один з методів
// програмування, який розглядає програму як множину "об'єктів",
// що взаємодіють між собою.
//
// ООП представляє програмне забезпечення як сукупність взаємних об'єктів,
// а не просто набір команд чи функцій як у традиційному програмуванні.
//
// У JavaScript є багато об'єктів які є вбудовані у ядро,
// так звані стандартні об'єкти JavaScript, наприклад-
// String, Number, Data i т.д.
//
// Кожен стандартний об'єкт являється екземпляром об'єкта Object,
// наслідуючи його властивості і методи.
//
// У JavaScript об'єкти це сукупність методів і властивостей.
//
// Властивість об'єкта це змінна яка належить об'єкту і містить значення
// певного типу даних.
//
// У JavaScript властивості є динамічними, що означає що їх можна
// додавати і видаляти з об'єкта.
//
// Метод об'єкта це функція яка належить об'єкту і виконує
// якусь певну дію для об'єкта.
//
// У JavaScript спочатку не було класів, але у ECMAScript6 з'явилися.
//
// Клас у JavaScript є шаблоном об'єкту і описує його властивості та методи.
// Описавши class створюють об'єкти за допомогою оператора new
//
// У JavaScript є наступні способи створення об'єкта:
// • Object()
//    var ob = new Object();
//    ob.prorerty = "text";
//    alert(ob.property);
// • Object.create()
//    var ob = Object.create(null, {property: {value:'text'}})
//    alert(ob.property)
// • Літеральний спосіб
//    var ob = {
//      property:'text',
//    }
//    alert(ob.property);
// • Функція-конструктор
//    function myOb(){
//      this.property = "test"
//    }
//    var ob = new myOb()
//    alert(ob.property) // 'test'
//    -----
//    class
//    class myOb{
//      constructor(){
//        this.property='test'
//      }
//    }
//    var ob = new myOb()
//    alert(ob.property)
//
// На відміну від інших мов програмування у JavaScript
// немає приватних властивостей, тобто властивостей
// які доступні лише для об'єкта і не доступна для створеного
// екземпляра об'єкта.
// --------------------------------------------------------------
//                    Основні поняття ОПП
// Уявіть, що проектуємо телефон. У нього буде екран, кнопки,
// зарядка і т.д. Телефон повинен мати можливість дзвонити,
// виходити в інтернет, фотографувати, тощо.
// --------------------------------------------------------------
//  Клас
// Ми описуємо всі запчастини з яких складається телефон,
// як ці запчастини взаємодіють між собою і що повинен зробити
// користувач, щоб телефон дзвонив, виходив в інтернет та інше
//
// Результатом роботи буде деякий ескіз(шаблон, схема)
//
// Ми щойно розробили те, що в ООП називається class
//
// Клас - це спосіб опису сутності, що визначає стан і поведінку,
// що залежить від цього стану, а також правила для взаємодії
// з цією сутністю(контракт).
//
// У нашому випадку клас описує сутність - телефон.
// Властивістю класу будуть камера, модем, дисплей і т.д.
// Методами класу - дзвонити, фотографувати і т.д.
// --------------------------------------------------------------
//  Об'єкт
// Ми спроектували креслення і схеми, за ними телефон сходить
// з конвеєра. Кожен з них точно повторює креслення, всі системи
// взаємодіють саме так, як ми спроектували, але кожен телефон
// є унікальним. Всі вони мають індивідуальний номер, колір,
// телефони відрізняються малюнками на панелі і т.д.
// Ці телефони є екземплярами типу
//
// Об'єкт(примірник) - це окремий представник класу,
// що має конкретний стан і поведінку, що повністю визначається класом.
// Це те, що створено за кресленням, тобто за описом із класу.
//
// Говорячи простою мовою, об'єкт має конкретні значення властивостей
// та методи, що працюють із цими властивостями на основі правил,
// заданих у класі. У даному прикладі, якщо клас це якийсь абстрактний
// телефон на кресленні, то об'єкт - це конкретний телефон, яким ви користуєтесь.
// --------------------------------------------------------------
//  Інтерфейс
// Коли ми підходимо до автомата за кавою або сідаємо за кермо автомобіля,
// існує певний набір елементів керування, з якими ми можемо взаємодіяти.
//
// Інтерфейс - це набір властивостей та методів класу, доступних для використання
// під час роботи з екземпляром.
//
// Насправді, інтерфейс специфікує клас, чітко визначаючи всі можливі дії над ним
// Хороший приклад інтерфейсу - панель приладів автомобіля, яка дозволяє
// викликати такі методи як збільшення швидкості, гальмування, поворот
// перемикання передач, включення фар і т.д.
//
// При описі інтерфейсу класу дуже важливо дотриматись балансу між гнучкістю
// і простотою. Клас із простим інтерфейсом буде легко використовувати,
// але існуватимуть завдання, які за допомогою нього вирішити буде не під силу
//
// Якщо інтерфейс буде гнучким, то швидше за все, він складатиметься
// з складних методів з великою кількістю параметрів, які дозволятимуть
// робити дуже багато, але використання буде пов'язано з ризиками щось переплутати.
// ==============================================================
// ==============================================================
//                  Парадигми
// ООП побудовано на чотирьох основних поняттях:
// 1. Інкапсуляція
// 2. Абстракція
// 3. Наслідування
// 4. Поліморфізм
// --------------------------------------------------------------
//   Інкапсуляція
// Внутрішні процеси роботи телефону досить складні.
// Але всі ці дії приховані від користувача і дозволяють йому
// дзвонити і писати, не замислюючись, що відбувається
// всередині. Саме приховування внутрішніх процесів, що відбуваються
// в телефоні, дозволяє ефективно використовувати його навіть новачкам.
// Це і є інкапсуляція.
//
// Інкапсуляція(incapsualtion) - це властивість системи,
// що дозволяє об'єднати дані та методи, що працюють з ними у класі
// та приховати деталі реалізації від користувача.
//
// Інкапсуляція пов'язана з поняттям інтерфейсу класу.
// Все те, що не входить до інтерфейсу, інкапсулюється(приховано) у класі.
// Користувач може працювати з усім функціоналом через інтерфейс,
// не замислюючись про те, як реалізований функціонал.
// --------------------------------------------------------------
//   Абстракція
// Коли ми телефонуємо, ми не замислюємось про хімічний склад фарби
// панелі, особливості взаємодії внутрішніх деталей тощо.
// Однак це не заважає нам використовувати весь функціонал.
//
// Абстрагування(abstraction) - це спосіб виділити набір
// значних показників об'єкта.
// --------------------------------------------------------------
//   Наслідування
// Уявімо, що інженерам поставили завднаяя розробки та випуску
// модельного ряду сучасніших смартфонів.
// При цьому вони вже мають стару модель, яка відмінно
// зарекомендувала себе. Очевидно, що інженери не проектуватимуть
// новий телефон з нуля, а взявши за основну попереднє покоління,
// внесуть низку змін.
// Усі модифікації матимуть більшість властивостей колишньої моделі.
// При цьому кожна з моделей реалізуватиме деяку нову функціональність
// або конструктивну особливість.
// У даному випадку ми маємо справу з успадкуванням.
//
// Спадкування(inheritance) - це властивість системи, що дозволяє
// описати новий клас на основі вже існуючого, з частково або повністю
// функціоналом, що запозичується.
//
// Клас, від якого виробляється успадкування, називається базовим,
// батьківським чи суперкласом.
//
// Новий клас називається нащадком, спадкоємцем чи похідним класом.
//
// Якщо взяти приклад із життя, то у нас HTML-елементи.
// У наступних модулях ми дізнаємось, що всі вони представлені об'єктами
// У них є загальні властивості та методи для керування станом.
// Замість того, щоб додавати загальні властивості на кожен тип елемента,
// ми можемо описати їх у класі HTMLElement, і ті елементи, яким
// потрібен подібний інтерфейс, можуть успадковувати HTMLElement.
//
// Спадкування допомагає зменшити обсяг коду, що повторюється.
// --------------------------------------------------------------
//   Поліморфізм
// Було б не дуже зручно, якби всі телефони функціонували по різному
// і власник андроїду не міг зателефонувати з айосу чи навпаки.
//
// Вся справа в тому, що основні елементи використання телефону
// мають одну й ту саму конструкцію та принцип дії.
// По суті, можна сказати що всі смартфони мають той самий інтерфейс,
// а користувач, абстрагуючись від сутності смартфону, працює саме
// з цим інтерфейсом. Незалежно від того, яким чином буде реалізовуватись
// дзвінок, інтерфейс залишиться тим самим.
//
// Поліморфізм(polymorphism) - це властивість системи, що дозволяє
// використовувати об'єкти з однаковим інтерфейсом без інформації про
// тип і внутрішню структуру об'єкта. Дозволяє перевизначити
// у класах спадкоємців реалізації методів базового класу.
// ==============================================================
// ==============================================================
//                     Конструктори
// Звичайний синтаксис літерал об'єкта {} дозволяє створити один
// об'єкт. Але найчастіше потрібно створити багато однотипних
// об'єктів, динамічно під час виконання програми.
//
// Для цього використовують функції конструктори, виключикаючи їх
// за допомогою спеціального оператора - new
//
// Конструктор - це звичайна функція до якої застосували оператор
// new. Це призводить до створення нового об'єкта та виклику функції
// у контексті цього об'єкта.
// --------------------------------------------------------------
//                   Функція-конструктор
// Технічно, функції-конструктори - це звичайні функції.
// Однак є дві загальні домовленості:
//  1. Ім'я функції-конструктора повинно починатися з великої літери
//  2. Функції-конструктори повинні виконуватися лише з оператором new
//  Наприклад:
/*
function User(name) {
	this.name = name;
	this.isAdmin = false;
}
let user = new User('Jack');
console.log(user.name); // Jack
console.log(user.isAdmin); // false
*/
// Коли функція виконується з new, відбуваються наступні кроки:
// • Створюється новий порожній об'єкт, якому присвоюється this
// • Виконується тіло функції. Зазвичай воно модифікує this,
//   додає до нього нові властивості
// • Повертається значення this.
//
// Будь-яка функція, крім стрілочної, може бути використана як конструктор,
// тобто викликана оператором new.
//
// При виклику стрілки через new буде помилка.
//
// Щоб відрізнити конструктор від звичайної функції, конструктори
// прийнято називати з великої літери, а саму назву відображати тип
// створюваного об'єкта.
//
// Ми вже працювали з конструкторами, вбудованими в мову:
// Object, Array, Number, String та інші.
//
// Використання конструкторів зручно при створенні безлічі об'єктів
// з одним набором властивостей, що мають різні значення.
// Тому таку функцію і називають конструктором - вона призначена
// для конструювання об'єктів за заздалегідь підготовленим шаблоном
// --------------------------------------------------------------
//           Внутрішні методи [[Call]] та [[Construct]]
// Функції викликаються використовуючи два різні внутрішні методи:
// [[Call]] та [[Construct]]
//
// Коли функція викликається без new, виконується метод [[Call]],
// який виконує тіло функції так, як описано в коді.
//
// Коли функція викликається з new, виконується метод [[Construct]],
// який відповідає за створення нового об'єкта і виконання
// тіла функції з цим, що посилається на цей об'єкт.
//
// Не всі функції мають внутрішній метод [[Construct]], і тому
// не всі функції можуть бути викликані через new.
//
// Стрілкові функції не мають методу [[Construct]], і тому не можуть
// бути використані як конструктори.
// --------------------------------------------------------------
//             Створення методів у конструкторі
// Використання конструкторів для створення об'єктів дає велику
// гнучкість. Конструктор може мати параметри, які визначають,
// як побудувати об'єкт і що в нього помістити.
//
// Звичайно, ми можемо додавати до this не лише властивості,
// але й методи.
//
// У наведеному нижче прикладі, new User(name) створює об'єкт
// із заданим name та методом sayHi:
/*
function User(name) {
	(this.name = name),
		(this.sayHi = function () {
			console.log(`My name is ${this.name}`);
		});
}
let john = new User('John');
john.sayHi();
*/
// ==============================================================
// ==============================================================
//         Object.prototype - прототип об'єкта Object
// prototype - властивість об'єкта Object, яка повертає прототип
// об'єкта.
//
// Прототип - це звичайний об'єкт, який ділиться своєю поведінкою
// з іншими об'єктами - тобто стає батьком об'єкта.
//
// Прототип використовується в основному для наслідування.
//
// Майже всі об'єкти в JavaScript є екземплярами Object і успадковують
// властивості, методи від Object.prototype. Хоча ці властивості
// можуть бути перевизначені.
//
// Зміни в Object.prototype об'єкта розглядаються на всіх об'єктах
// через прототип ланцюжка, якщо властивості і методи не будуть
// перезаписані далі по ланцюжку прототипів.
//
// Object.prototype знаходиться на вершині ланцюжка прототипів.
//
// Всі об'єкти в JavaScript є нащадками Object.
// Всі об'єкти успадковують методи і властивості з прототипу об'єкта
// Object.prototype.
// Хоча вони і можуть бути перевизначені.
//
// Наприклад, прототипи інших конструкторів скасовують властивість
// constructor і передають власні методи toString()
// --------------------------------------------------------------
//   Властивості:
// • Object.constructor - визначає функцію, яка створює прототип об'єкта
// • Object.__proto__ - вказує на об'єкт, який використовувався в якості
//   прототипу при інстанціруванні об'єкта.
// • Object.__noSuchMethod__ - дозволяє визначити функцію, виконується
//   в якості методу не певного члена об'єкта.
// • Object.__count__ - використовувалося для повернення кількості
//   перерахованих властивостей, певних безпосередньо на призначеному
//   для користувача об'єкті, але було видалено.
// • Object.__parent__ - використовувалося для вказівки контексту
//   об'єкта, але було видалено.
//
//   Методи:
// • Object.__defineGetter__() - асоціює функцію з властивістю, яка,
//   при доступі до нього, виконує цю функцію і повертає її значення, що повертається
// • Object.__defineSetter__() - асоціює функцію з властивістю, яка,
//   при його установці, виконує цю функцію, змінює властивість.
// • Object.__lookupGetter__() - повертає функцію, пов'язану із зазначеними
//   властивістю методом - __defineGetter__
// • Object.__lookupSetter__() - повертає функцію, пов'язану із зазначеними
//   властивістю методом - __defineSetter__
// • Object.hasOwnProperty() - чи містить вказана властивість безпосередньо
//   об'єкт, або він успадкував його по ланцюжку прототипів.
// • Object.isPrototypeOf() - чи перебуває зазначений об'єкт в ланцюжку
//   прототипів об'єкта, на якому був викликаний цей метод.
// • Object.propertyIsEnumerable() - повертає логічне значення, яке вказує,
//   чи встановлений внутрішній атрибут ECMAScript DontEnum.
// • Object.toSource() - повертає рядок, що містить вихідни код об'єкта.
// • Object.toLocaleString() - повертає рядкове представлення об'єкту
//   згідно локалі.
// • Object.toString() - повертає строкове представлення об'єкту.
// • Object.unwatch() - видаляє точку спостереження (watchpoint)
//   з властивовстей об'єкта
// • Object.watch() - додає точку спостереження (watchpoint)
//   до властивовстей об'єкта
// • Object.valueOf() - повертає значення примітиву зазначеного об'єкта.
// --------------------------------------------------------------
//                 Коротка історія
// Якщо порахувати всі способи керування властивістю [[Prototype]],
// їх буде багато! Багато способів робити
// ОДНЕ Й ТЕ Ж САМЕ!
// ЧОМУ?
// Так склалося історично.
// Властивість "prototype" функції-конструктора реалізована з самих
// давних часів.
// Пізніше, в 2012 році, метод Object.create став стандартом.
// Це дало можливість створювати об'єкти з певним прототипом,
// проте не дозволяло отримувати або встановлювати його.
// Тому браузери реалізували нестандартний аксесор - __proto__,
// котрий дозволяв користувачу отримувати та встановлювати прототип
// в будь-який час. Ще пізніше, в 2015 році, методи
// Object.setPrototypeOf та Object.getPrototypeOf були додані до
// стандарту, для того, щоб виконувати аналогічну функціональність
// як і __proto__.
//
// Оскільки __proto__ було широко реалізовано,
// воно згадується в Додату В стандарту, як не обов'язкове для
// не-браузерних середовищ, але вважається свого роду застарілим.
// --------------------------------------------------------------
//           Методи прототипів, об'єкти без __proto__
// Властивість __proto__ вважається застарілою(підтримується
// браузером відповідно до стандарту)
//
// Сучасні методи:
// • Object.create(proto, [descriptors]) - створює пустий об'єкт
//   з властивістю [[Prototype]], що посилається на переданий об'єкт
//   proto, та необов'язковими до передачі дескрипторами властивостей
//   descriptors.
// • Object.getPrototypeOf(obj) - повертає значення [[Prototype]]
//   об'єкту obj.
// • Object.setPrototypeOf(obj, proto) - встановлює значення [[Prototype]]
//   об'єкту obj рівне proto.
//
// Ці методи необхідно використовувати на відміну від __proto__
// --------------------------------------------------------------
//                     "Прості об'єкти"
// Як ми знаємо, об'єкти можуть використовуватися як асоціативні масиви
// для зберігання пар ключ: значення,
//
// Проте якщо ми спробуємо збереги створені користувачем ключі в ньому
// (наприклад, словник з користувацьким вводом), ми можемо спостерігати
// цікавий збій:
// усі ключі працюють правильно окрім "__proto__".
// Розгляньте приклад:
/*
let obj = {};
let key = prompt('Enter key', '__proto__');
obj[key] = 'some entering';
alert(obj[key]);
*/
// В цьому випадку, якщо користувач введе __proto__, присвоєння проігнорується!
//
// Це не повинно дивувати нас. Властивість __proto__ є особливою:
// вона має бути або об'єктом, або null. Рядок не може стати прототипом.
//
// Проте ми не намагалися реалізувати таку поведінку.
// Ми хотіли зберегти пари ключ: значення і при цьому ключ з назвою
// "__proto__" не зберігся. Тому це помилка!
